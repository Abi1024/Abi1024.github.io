/* Abiyaz Chowdhury, French POS tagger. NLP Spring 2016*/const language = "English";PFont myFont;HashMap<String, Float> start_probability = {};HashMap<String, HashMap<String, Float>> transition = {};HashMap<String, HashMap<String, Float>> emission = {}; //emission maps the state to the observation to the probabilityArrayList<String> state_space = [];HashMap<String, Integer> state_space2 = [];Float smoothing = -50.0;void setup() {  strokeWeight(1);  size(1000, 800);  train();  test();}void train() {  lines = {};  println("training");  if (language === "English"){     lines = loadStrings("english_training.txt");  }else if (language === "French"){    lines = loadStrings("french_training.txt");  }  String previous_state = "SENT";  String previous_word = "";  for (int i = 0; i < lines.length; i++) {    String words[] = lines[i].split("\\s+");    if ((words.length >= 2)&&(!words[0].equals(""))&&(!words[1].equals(""))) {      if ((words[1].indexOf(':') != -1)&&(words[1].length()>1)) {        words[1] = words[1].substring(0, words[1].indexOf(':'));      }      words[0] = words[0].toLowerCase();      //println("Current token: " + words[0] + " " + words[1] + " Previous state: " + previous_state);      if (emission.get(words[1]) == null) {        if (words[1].equals("")){            println("error");        }        emission.put(words[1], new HashMap<String, Float>());        //println(words[0]+"\t"+words[1]);      }      HashMap<String, Float> innerMap = emission.get(words[1]);      Float count = innerMap.containsKey(words[0]) ? innerMap.get(words[0]) : 0; //update emission count      innerMap.put(words[0], count + 1);      //println("1"+previous_state+"1");      if (previous_state.equals("SENT")) {        //println("sentential token");        start_probability.put(words[1], count+1);        //println("start of new sentence: " + words[0] + " " + words[1] + " previous word: " + previous_word);      } else if (!previous_state.equals("")) {        if (transition.get(previous_state) == null) {          transition.put(previous_state, new HashMap<String, Float>());        }        HashMap<String, Float> innerMap2 = transition.get(previous_state);        Float count2 = innerMap2.containsKey(words[1]) ? innerMap2.get(words[1]) : 0; //update emission count        innerMap2.put(words[1], count2 + 1);      }      previous_state = words[1];      previous_word = words[0];    }  }  //println(transition.get("KON").get("DET"));  Float sum = 0.0;  for (Map.Entry<String, Float> entry : start_probability.entrySet()) {    //System.out.println(entry.getKey() + "/" + entry.getValue());    sum += entry.getValue();  }  for (Map.Entry<String, Float> entry : start_probability.entrySet()) {    //System.out.println(entry.getKey() + "/" + entry.getValue());    start_probability.put(entry.getKey(), new Float(Math.log(entry.getValue()/sum)));    //println("Start probability: " + entry.getKey() + " " + entry.getValue());  }  for (Map.Entry<String, HashMap<String, Float>> entry : emission.entrySet()) {    state_space.add(entry.getKey());    sum = 0.0;    HashMap<String, Float> innerMap = entry.getValue();    for (Map.Entry<String, Float> entry2 : innerMap.entrySet()) {      //System.out.println(entry.getKey() + "/" + entry.getValue());      sum += entry2.getValue();    }    for (Map.Entry<String, Float> entry2 : innerMap.entrySet()) {      //System.out.println(entry.getKey() + "/" + entry.getValue());      innerMap.put(entry2.getKey(), new Float(Math.log(entry2.getValue()/sum)));    }  }  for (Map.Entry<String, HashMap<String, Float>> entry : transition.entrySet()) {    sum = 0.0;    HashMap<String, Float> innerMap = entry.getValue();    for (Map.Entry<String, Float> entry2 : innerMap.entrySet()) {      //System.out.println(entry.getKey() + "/" + entry.getValue());      sum += entry2.getValue();    }    for (Map.Entry<String, Float> entry2 : innerMap.entrySet()) {      //System.out.println(entry.getKey() + "/" + entry.getValue());      innerMap.put(entry2.getKey(), new Float(Math.log(entry2.getValue()/sum)));    }  }  //test the above  /*for (Map.Entry<String, HashMap<String, Float>> entry : emission.entrySet()) {   for (Map.Entry<String, Float> entry2 : entry.getValue().entrySet()) {   println("In state: " + entry.getKey() + " the probability of observing " + entry2.getKey() + " is " + entry2.getValue());   }   }*/  for (Map.Entry<String, HashMap<String, Float>> entry : transition.entrySet()) {   for (Map.Entry<String, Float> entry2 : entry.getValue().entrySet()) {   //println("In state: " + entry.getKey() + " the probability of transitioning into state " + entry2.getKey() + " is " + entry2.getValue());   }   }  for (int i = 0; i < state_space.size(); i++) {    state_space2.put(state_space.get(i), i);    //println("@"+state_space.get(i) + "@ " + i);  }}void test() {  println("Testing");  String lines[] = loadStrings("test.txt");  ArrayList<String> buffer = new ArrayList<String>();  for (int i = 0; i < lines.length; i++) {    String words[] = lines[i].split("[\\s+]|(?=[!?.,:;\"])|(?<=[!?.,:;\"])");    for (int j = 0; j < words.length; j++) {      words[j] = words[j].replaceAll("[()]","");      if ((words[j].equals(".")||(words[j].equals("?"))||(words[j].equals("!")))) {        ArrayList<String> tags = viterbi(buffer);        buffer.clear();      } else if (words[j].length() > 0){        buffer.add(words[j].toLowerCase());      }    }  }}ArrayList<String> viterbi(ArrayList<String> sentence) {  println("Running viterbi on the following sentence");  int sentence_length = sentence.size();  for (int i = 0; i < sentence_length; i++){     print(sentence.get(i) + " ");   }  println();  int num_states = emission.size();  Float intermediate_matrix[][] = new Float[num_states][sentence_length];  int backtrace[][] = new int[num_states][sentence_length];  for (int i = 0; i < sentence_length; i++) {    //println("Computing forward path, currently on word: " + sentence.get(i));    for (int j = 0; j < num_states; j++) {      //println("\tCalculating probabilities for state: " + state_space.get(j));      if ((i==0)&&(!state_space.get(j).equals("SENT"))) { //start probability vector        if (emission.get(state_space.get(j)).get(sentence.get(i)) == null){  ///////////////////////////////////////////////////              emission.get(state_space.get(j)).put(sentence.get(i),smoothing);        }        if (start_probability.get(state_space.get(j)) == null){ //////////////////////////////////////////////////              start_probability.put(state_space.get(j),smoothing);        }        //println("\tStart probability:\t " + Math.log(start_probability.get(state_space.get(j))));        //println("\tEmission probability:\t " + Math.log(emission.get(state_space.get(j)).get(sentence.get(i))));        intermediate_matrix[j][i] = start_probability.get(state_space.get(j))+emission.get(state_space.get(j)).get(sentence.get(i));        //println("\tViterbi probability:\t " + Math.log(intermediate_matrix[j][i]));      } else if (!state_space.get(j).equals("SENT")){        if (emission.get(state_space.get(j)).get(sentence.get(i)) == null){  ///////////////////////////////////////////////////           emission.get(state_space.get(j)).put(sentence.get(i),smoothing);        }        //println("\tEmission probability: " + Math.log(emission.get(state_space.get(j)).get(sentence.get(i))));        intermediate_matrix[j][i] = -9999.0;        for (int k = 0; k < num_states; k++) {          if (!state_space.get(k).equals("SENT")){            if (transition.get(state_space.get(k)) == null){               println("yep");             }            if (transition.get((state_space.get(k))).get(state_space.get(j)) == null){ //////////////////////////////////////////////////                transition.get((state_space.get(k))).put(state_space.get(j),smoothing);            }           //println("\t\tTransition probability: " + state_space.get(k) + "\t" + Math.log(transition.get((state_space.get(k))).get(state_space.get(j))));            if (intermediate_matrix[k][i-1]+transition.get((state_space.get(k))).get(state_space.get(j)) > intermediate_matrix[j][i]) {              intermediate_matrix[j][i] = intermediate_matrix[k][i-1]+transition.get(state_space.get(k)).get(state_space.get(j));              backtrace[j][i] = k;            }          }        }        intermediate_matrix[j][i] += emission.get(state_space.get(j)).get(sentence.get(i));        //println("\tBest previous state: " + state_space.get(backtrace[j][i]));        if (intermediate_matrix[j][i]==0){         //println("error");         }        //println("\tViterbi probability: " + Math.log(intermediate_matrix[j][i]));      }      }  }  /*for (int i = 0; i < num_states;i++){     if (!state_space.get(i).equals("SENT")){       print(state_space.get(i) + "\t");       for (int j = 0; j < sentence_length; j++){          print(String.format("%.2f \t",intermediate_matrix[i][j]));       }     }     println();  }*/  Float max = -9999.0;  int index = -1;  for (int i = 0; i < num_states; i++) {    if ((!state_space.get(i).equals("SENT"))&&(intermediate_matrix[i][sentence_length-1] > max)) {      max = intermediate_matrix[i][sentence_length-1];      index = i;    }  }  int k = index;  Stack<String> backtrace_path = new Stack<String>();  for (int i = 0; i < sentence_length; i++){    //println(state_space.get(k));    backtrace_path.push(state_space.get(k));    k = backtrace[k][sentence_length-1-i];  }  ArrayList<String> result = new ArrayList<String>();   while (backtrace_path.size() != 0){    result.add(backtrace_path.pop());  }  for (int i = 0; i < sentence_length; i++){     println(sentence.get(i) + "\t" + result.get(i));   }  println("Viterbi successful");  return result;}